package DanMu.constraints;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.base.BaseConstraintsDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.runtime.PropertyConstraintsDescriptor;
import java.util.HashMap;
import jetbrains.mps.smodel.runtime.base.BasePropertyConstraintsDescriptor;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class Wait_Constraints extends BaseConstraintsDescriptor {
  public Wait_Constraints() {
    super(MetaAdapterFactory.getConcept(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x14aa56594cd7c79dL, "DanMu.structure.Wait"));
  }

  @Override
  protected Map<SProperty, PropertyConstraintsDescriptor> getSpecifiedProperties() {
    Map<SProperty, PropertyConstraintsDescriptor> properties = new HashMap<SProperty, PropertyConstraintsDescriptor>();
    properties.put(MetaAdapterFactory.getProperty(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x14aa56594cd7c79dL, 0x1149ba63db400b66L, "pastSeond"), new BasePropertyConstraintsDescriptor(MetaIdFactory.propId(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x14aa56594cd7c79dL, 0x1149ba63db400b66L), this) {
      @Override
      public boolean hasOwnGetter() {
        return true;
      }
      @Override
      public Object getValue(final SNode node) {
        String propertyName = "pastSeond";
        {
          final Wrappers._int ret = new Wrappers._int(0);
          final Wrappers._boolean b = new Wrappers._boolean(false);
          ListSequence.fromList(SNodeOperations.getNodeAncestors(node, MetaAdapterFactory.getConcept(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x1149ba63db31c4f5L, "DanMu.structure.Commands"), false)).translate(new ITranslator2<SNode, SNode>() {
            public Iterable<SNode> translate(SNode it) {
              return SLinkOperations.getChildren(it, MetaAdapterFactory.getContainmentLink(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x1149ba63db31c4f5L, 0x1149ba63db31c4f6L, "commands"));
            }
          }).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              if (!(b.value) && SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x14aa56594cd7c79dL, "DanMu.structure.Wait"))) {
                SNode nw = (SNode) it;
                ret.value = ret.value + SPropertyOperations.getInteger(nw, MetaAdapterFactory.getProperty(0xf308bac3fb954e51L, 0x8457a8a5d4e826acL, 0x14aa56594cd7c79dL, 0x14aa56594cd7c79eL, "second"));
                if (nw == node) {
                  b.value = true;
                }
              }
            }
          });
          return ret.value;
        }
      }
    });
    return properties;
  }
}
